# Let's measure speedup for each algorithm along different matrix sizes
mkdir -p results
chmod +x build/benchmark-*
echo "computing speedups"
for N in 128 512 2048; do
  for T in 1 4 16 64; do
    export OMP_NUM_THREADS=$T
    echo "N=${N} T=${T}"
    # blas
    if [ $T -eq 1 ]; then
      eval "build/benchmark-blas -N ${N} 2> ./results/blas_${N}_1_rt"
    fi
    # basic
    eval "build/benchmark-basic-omp -N ${N} 2> ./results/basic_${N}_${T}_rt"
    # blocked
    for B in 4 16; do
      eval "build/benchmark-blocked-omp -N ${N} -B ${B} 2> ./results/blocked-${B}_${N}_${T}_rt"
    done
    # strassen
    for L in 64 256 512; do
      eval "build/benchmark-strassen-${L}-omp -N ${N} 2> ./results/strassen-${L}_${N}_${T}_rt"
    done
  done
done

# Let's measure performance counter for each algorithm along different matrix sizes, but without threading
module load e4s/23.05
spack env activate gcc
spack load likwid
export OMP_NUM_THREADS=1
echo "computing performance counters"
for N in 128 512 2048; do
  for perf_counter in "FLOPS_DP" "L2CACHE" "L3CACHE"; do
    echo "N=${N} perf_counter=${perf_counter}"
    # blas
    eval "likwid-perfctr -g ${perf_counter} -m -C N:0-0 ./build/benchmark-blas -N ${N} > ./results/blas_${N}_${perf_counter}"
    # basic
    eval "likwid-perfctr -g ${perf_counter} -m -C N:0-0 ./build/benchmark-basic-omp -N ${N} > ./results/basic_${N}_${perf_counter}"
    # blocked
    for B in 4 16; do
      eval "likwid-perfctr -g ${perf_counter} -m -C N:0-0 ./build/benchmark-blocked-omp -N ${N} -B ${B} > ./results/blocked-${B}_${N}_${perf_counter}"
    done
  done
done